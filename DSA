1} PROGRAM ON STRINGS (PATTERN MATCHING)
#include&lt;stdio.h&gt;
#include&lt;string.h&gt;
int find_match(char str[10],char pat[100],char rep[100],char ans[100]);
void main()
{
char str[100],pat[100],rep[100],ans[100];
int flag;
printf(&quot;enter the main string\n&quot;);
gets(str);
printf(&quot;enter the pattern string to be searched\n&quot;);
gets(pat);
printf(&quot;enter the replacement string\n&quot;);
gets(rep);
flag= find_match(str,pat,rep,ans);
if(flag)
{
printf(&quot;\n pattern found\n&quot;);
printf(&quot;\n the string after replacement is %s&quot;,ans);

}
else
printf(&quot;\n pattern not found\n&quot;);

}
int find_match(char str[100],char pat[100],char rep[100],char ans[100])
{
int i,j,m,c,flag,k;
i=j=m=c=flag=0;
while(str[c]!=&#39;\0&#39;)
{
if(str[m]==pat[i])
{
i++; m++;
if(pat[i]==&#39;\0&#39;)
{
flag=1;
for(k=0; rep[k]!=&#39;\0&#39;; k++, j++)
{
ans[j] =rep[k];
}
i=0;
c=m;

}
}
else
{

ans[j]=str[c];
j++;
c++;
m=c;
i=0;
}
}
ans[j]=&#39;\0&#39;;
return flag;
}





2) Design, Develop and Implement a menu driven Program in C for the following
operations on STACK of Integers (Array Implementation of Stack with maximum size
MAX)
a. Push an Element on to Stack
b. Pop an Element from Stack
c. Demonstrate how Stack can be used to check Palindrome
d. Demonstrate Overflow and Underflow situations on Stack
e. Display the status of Stack
f. Exit
Support the program with appropriate functions for each of the above operations
#include <stdio.h>
#include<stdlib.h>
#define MAX 5
int stack[MAX], item, ch, top=-1, status=0;
void push(int stack[],int item)
{
 if(top==(MAX-1))
 printf("\nOverflow\n");
 else
 stack[++top]=item;
 status++;
}
int pop()
{
 if(top==-1)
 printf("\nUnderflow\n");
 else
 return stack[top--];
 status--;
}
void palindrome(int stack[])
{
int temp, count=0;
temp=status;
for(int i=0;i<temp;i++)
{
if(stack[i]==pop())
count++;
}
if(count==temp)
printf("Palindrome\n");
else
printf("not palindrome\n");
}
void display(int stack[])
{
 if(top==-1)
 printf("\nstack is empty\n");
 else
 for(int i=top;i>=0;i--)
 {
 printf("|%d|\n",stack[i]);
 }
}
void main()
{
 int ch;
 while(ch<6)
 {
 printf("\n 1.push\t 2.pop\t 3.palindrome\t 4.display\t 5.exit\n");
 printf("Enter the choice: ");
 scanf("%d",&ch);
 switch(ch)
 {
 case 1: printf("Enter the item: ");
 scanf("%d",&item);
 push(stack,item);
 break;
 case 2: printf("popped value = %d",pop());
 break;
 case 3: palindrome(stack);
 break;
 case 4: display(stack);
 break;
 case 5: exit(0);
 default: printf("Invalid Choice\n");
 break;
 }
 }
}




3) Design, Develop and Implement a Program in C for the following operations on
expression.
a. Read infix expression String (INFIX)
b. Convert the infix expression (INFIX) to a postfix expression using stacks.
c. Evaluate the postfix expression using stacks.
d. Check the following test cases.
Test Case 1: Infix = “(1+ (2-3) *4)”, Postfix=”123-4*+”, Result = -3
Test Case 2: Infix = “4/2-2+3*3-4*2”, Postfix=”42/233*42*-+-”, Result = -1
Note: Program should support for both parenthesized and free parenthesized expressions
with the operators: +, -, *, /, % (Remainder), ^ (Power) and alphanumeric operands.
#include <stdio.h>
#include <ctype.h>
#include <math.h>
char stack[100];
int top = -1;
void push(char x)
{
stack[++top] = x;
}
char pop()
{
if(top == -1)
return -1;
else
return stack[top--];
}
int priority(char x)
{
if(x == '(')
return 0;
if(x == '+' || x == '-')
return 1;
if(x == '*' || x == '/' || x=='%')
return 2;
if(x=='^')
return 3;
return 0;
}
void main()
{
char exp[20];
char *e, x;
printf("enter the expression : ");
scanf("%s", exp);
printf("\n");
e = exp;
while (*e != '\0')
{
if(isalnum(*e))
printf("%c", *e);
else if (*e == '(')
push(*e);
else if(*e == ')')
{
while ((x = pop()) != '(')
printf("%c", x);
}
else{
while(priority(stack[top]) >= priority(*e))
printf("%c", pop());
push(*e);
}
e++;
}
while(top != -1)
{
printf("%c", pop());
}
char postfix[20];
char *p;
int n1,n2,n3,num;
printf("\nEnter the result to calculate :: ");
scanf("%s",postfix);
p = postfix;
while(*p != '\0')
{
if(isdigit(*p))
{
num = *p - 48;
push(num);
}
else
{
n1 = pop();
n2 = pop();
switch(*p)
{
 case '+':
 {
 n3 = n2 + n1;
 break;
 }
 case '-':
 {
 n3 = n2 - n1;
 break;
 }
 case '*':
 {
 n3 = n2 * n1;
 break;
 }
 case '/':
 {
 n3 = n2 / n1;
 break;
 }
 case '^':
 {
 n3 = pow(n2,n1);
 break;
 }
 case '%':
 {
 n3 = n2%n1;
 break;
 }
 }
 push(n3);
 }
 p++;
 }
 printf("\nThe result of the converted postfix = %d",pop());
 }





4) Design, Develop and implement menu driven program to simulate
processing of batch jobs by a computer system. The scheduling of these
jobs should be handled using a priority queue.
Note: The Program should allow users to add or remove items from
the queue and it should also display current status i.e. the total number
of items in the queue.
#include &lt;stdio.h&gt;
#include&lt;stdlib.h&gt;
#define MAX 5
int front=-1, rear=-1;
typedef struct process
{
int pr;
}job;
job pjob[MAX];
void insert()
{
int pr;
if(rear==MAX-1)
{
printf(&quot;Overflow&quot;);
}
else
{
printf(&quot;Enter PRIORITY: &quot;);
scanf(&quot;%d&quot;,&amp;pr);
if(rear = = -1)
{
rear + +;
front + +;
}
else
{
rear++;
}
pjob[rear].pr=pr;
}
}
void delete()
{
int i, pos=0,pmax=0,pr;
if(front==-1)
{
printf(&quot;Underflow\n&quot;);
}
else if(front==rear)
{
front=-1;

rear=-1;
}
else
{
for(i=front;i&lt;=rear;i++)
{
if(pjob[i].pr&gt;pmax)
{
pmax=pjob[i].pr;
pr=i;
}
}
for(i=pr;i&lt;=rear;i++)
{
pjob[i].pr=pjob[i+1].pr;
}
rear--;
}
}
void display()
{
if(front==-1)
{
printf(&quot;Queue is Empty\n&quot;);
}
else
{
printf(&quot;PRIORITY&quot;);
for(int i=front;i&lt;=rear;i++)
{
printf(&quot;%d&quot;, pjob[i].pr);
}
}
}
void main()
{
int ch;
while(1)
{
printf(&quot;\n1.Insert\t 2.Display\t 3.Delete\t 4.Exit\n&quot;);
printf(&quot;\nEnter your choice: &quot;);
scanf(&quot;%d&quot;, &amp;ch);
switch(ch)
{
case 1: insert(); break;
case 2: display(); break;
case 3: delete(); break;
case 4: exit(0); break;
default: printf(&quot;\nInvalid choice:\n&quot;); break;
}
}
}





5th 
#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;
typedef struct node
{
int data;
struct node *link;
}NODE;
NODE *A, *B, *C, *D;
NODE* insert(NODE **first, int num)
{
NODE* newNode = (NODE*) malloc(sizeof(NODE));
newNode-&gt;data = num;
newNode-&gt;link = *first;
*first = newNode;
return *first;
}
int search(NODE *first, int num)
{
while (first != NULL)
{
if (first-&gt;data == num)
{
return 1;
}
first= first-&gt;link;
}
return 0;
}
NODE* findunion(NODE *A, NODE *B)
{
C = NULL;
NODE *temp=A;
while(temp != NULL)
{
insert(&amp;C, temp-&gt;data);
temp = temp-&gt;link;
}
while(B != NULL)
{
if(!search(A, B-&gt;data))
{
insert(&amp;C, B-&gt;data);

}
B = B-&gt;link;
}
return C;

}

NODE* intersection(NODE *A, NODE *B)
{
D = NULL;
while(A != NULL)
{
if(search(B, A-&gt;data))
{
insert(&amp;D, A-&gt;data);
}
A = A-&gt;link;
}
return D;
}

void printList(NODE *cur)
{
while (cur!= NULL)
{
printf(&quot;--&gt;%d&quot;, cur-&gt;data);
cur = cur-&gt;link;
}
}

void main()
{
int i, Acount, Bcount, temp;
printf(&quot;\n Enter number of nodes in first Linked List: &quot;);
scanf(&quot;%d&quot;, &amp;Acount);
printf(&quot;\n Enter data of first linked list: &quot;);
for(i=0; i&lt;Acount; i++)
{
scanf(&quot;%d&quot;, &amp;temp);
insert(&amp;A, temp);
}
printList(A);
printf(&quot;\n Enter number of nodes in second Linked List: &quot;);
scanf(&quot;%d&quot;, &amp;Bcount);
printf(&quot;\n Enter data of second linked list: &quot;);

for(i=0; i&lt;Bcount; i++)
{
scanf(&quot;%d&quot;, &amp;temp);
insert(&amp;B, temp);
}
printList(B);
findunion(A, B);
intersection(A, B);
printf(&quot;\nUnion of two Linked List\n&quot;);
printList(C);
printf(&quot;\nIntersection of two Linked List\n&quot;);
printList(D);
}




6th programm 
#include&lt;stdio.h&gt;
typedef struct node
{
int data;
struct node *link;
}NODE;

NODE *start= NULL;
void create_list()
{
NODE *newnode=NULL;
int n,i;
printf(&quot;enter the number of nodes\n&quot;);
scanf(&quot;%d&quot;,&amp;n);
for(i=1;i&lt;=n;i++)
{
insert_front();
}
}
void insert_front()
{
NODE *newnode=NULL;
newnode=(NODE*)malloc(sizeof(NODE));
printf(&quot;enter data\n&quot;);
scanf(&quot;%s&quot;,newnode-&gt;data);
newnode-&gt;link=start;
start=newnode;
}
void del_front()
{
NODE* curptr=NULL;
if(start==NULL)
printf(&quot;\n LIST EMPTY\n&quot;);
else
{
curptr=start;
start=start-&gt;link;
printf(&quot;the deleted information is \n&quot;);
printf(&quot; %d &quot;,curptr-&gt;data);
free(curptr);
}
}

2

void insert_end()
{
NODE * curptr,*newnode=NULL;
newnode=(NODE*)malloc(sizeof(NODE));
printf(&quot;enter data“);
scanf(&quot;%s&quot;,newnode-&gt;data);
if(start==NULL)
{
newnode-&gt;link=start;
start=newnode;
}
else
{
curptr=start;
while(curptr-&gt;link !=NULL)
curptr=curptr-&gt;link;
newnode-&gt;link=NULL;
curptr-&gt;link=newnode;
}
}
void del_end()
{
NODE *curptr=NULL,*prv=NULL;
if(start==NULL)
printf(&quot;\n LIST EMPTY\n&quot;);
else if(start-&gt;link==NULL)
free(start);
else
{
curptr=start;
prv=curptr;
while(curptr-&gt;link!=NULL)
{
prv=curptr;
curptr=curptr-&gt;link;
}
prv-&gt;link=NULL;
free(curptr);
}
}

3

void display()
{
NODE*curptr=NULL;
if(start==NULL)
printf(&quot;\n LIST EMPTY\n&quot;);
else
{
curptr=start;
printf(&quot;\n data &quot;);
while(curptr!=NULL)
{
printf(&quot;%d &quot;,curptr-&gt;data);
curptr=curptr-&gt;link;
}
}
}
int count_nodes()
{
NODE * curptr =NULL;
int ctr=0;
if(start==NULL)
return 0;
else
{
curptr=start;
while(curptr!=NULL)
{
ctr++;
curptr=curptr-&gt;link;
}
}
return ctr;
}



7th 
#include&lt;stdio.h&gt;
void tower(int n, char s, char t, char d)
{
if(n==1)
{
printf(&quot;Move disc 1 from %c to %c\n&quot;, s, d);
return;
}
tower(n-1, s, d, t);
printf(&quot;Move disc %d from %c to %c\n&quot;, n, s,d);
tower(n-1, t, s, d);
}
void main()
{
int n;
printf(&quot;Enter the number of discs\n&quot;);
scanf(&quot;%d&quot;, &amp;n);
tower(n, &#39;A&#39;,&#39;B&#39;,&#39;C&#39;);
}
